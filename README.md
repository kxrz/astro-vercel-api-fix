# Fixing API Routes on Astro + Vercel (405 & Module Not Found Errors)

> **TL;DR**: If your Astro API routes return 405 errors, HTML instead of JSON, or `ERR_MODULE_NOT_FOUND` on Vercel, you likely have config conflicts between Astro's adapter and Vercel's deployment system. This guide shows you how to fix it.

## Problem Statement

When deploying Astro projects with API routes to Vercel, you may encounter:

- **405 Method Not Allowed** errors on `/api/*` endpoints
- **JSON parse errors** in the browser (`SyntaxError: Unexpected token 'A'...`)
- **Module not found** errors: `ERR_MODULE_NOT_FOUND: Cannot find module '/var/task/dist/server/entry.mjs'`
- Vercel logs showing **"HIT"** instead of function execution
- Routes returning **HTML** when you expect **JSON**

These issues typically occur when:
1. Using `output: 'hybrid'` mode incorrectly
2. Having duplicate API definitions (Astro + native Vercel functions)
3. Overriding Astro's adapter config with a custom `vercel.json`
4. Manipulating the build output manually

## Root Causes

### 1. Hybrid Mode Confusion
Astro's `hybrid` mode allows mixing static and dynamic routes, but Vercel may treat your API routes as static assets, causing them to return HTML or fail entirely.

### 2. Duplicate API Definitions
Having both `src/pages/api/*.ts` (Astro) and `api/*.ts` (Vercel native functions) creates conflicts. Vercel's routing can't determine which to serve.

### 3. Custom `vercel.json` Interference
When you provide a `vercel.json` with custom `functions`, `rewrites`, or `routes` config, you override the automatic configuration generated by Astro's adapter, breaking the deployment.

### 4. Deprecated Adapter
Using `@astrojs/vercel/serverless` (deprecated) instead of `@astrojs/vercel` can cause unexpected behavior.

## The Solution

### Step 1: Configure Astro for Full SSR

Update your `astro.config.mjs`:

```js
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel';

export default defineConfig({
  output: 'server',  // Full SSR mode
  adapter: vercel(), // Modern adapter (not /serverless)
  // ... other config
});
```

**Why this works**: 
- `output: 'server'` treats all routes as server-side by default
- Vercel correctly identifies them as serverless functions
- The modern `@astrojs/vercel` adapter handles the build configuration automatically

### Step 2: Explicitly Disable Prerendering for API Routes

In each API route file, add:

```ts
// src/pages/api/newsletter.ts
export const prerender = false; // Critical!

import type { APIRoute } from 'astro';

export const POST: APIRoute = async ({ request }) => {
  try {
    const data = await request.json();
    
    // Your logic here
    
    return new Response(
      JSON.stringify({ success: true }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
};
```

**Key points**:
- Always export `prerender = false` at the top
- Always return JSON, even for errors
- Use proper status codes and headers

### Step 3: Remove Conflicting Configurations

**Delete or remove**:
- âŒ `vercel.json` (unless absolutely necessary for non-Astro features)
- âŒ Native Vercel functions in `api/*.ts` directory
- âŒ Custom build scripts that modify `dist/server/`
- âŒ Manual rewrites or function declarations

**Why**: Let Astro's adapter handle the Vercel configuration. It knows how to set up functions correctly.

### Step 4: Install Correct Dependencies

```bash
npm install @astrojs/vercel
```

Ensure you're NOT using:
- `@astrojs/vercel/serverless` (deprecated)
- `@astrojs/vercel/static` (for static-only sites)

## Complete Working Example

**Project Structure**:
```
my-astro-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ contact.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ newsletter.ts
â”‚   â”‚   â”‚   â””â”€â”€ download-pdf.ts
â”‚   â”‚   â”œâ”€â”€ contact.astro
â”‚   â”‚   â””â”€â”€ index.astro
â”‚   â””â”€â”€ ...
â”œâ”€â”€ astro.config.mjs
â””â”€â”€ package.json
```

**Example API Route** (`src/pages/api/contact.ts`):

```ts
export const prerender = false;

import type { APIRoute } from 'astro';

export const POST: APIRoute = async ({ request }) => {
  console.log('ðŸ“§ [Contact] Received request');
  
  try {
    const { email, subject, message } = await request.json();
    
    // Validate
    if (!email || !subject || !message) {
      return new Response(
        JSON.stringify({ 
          error: 'Missing required fields' 
        }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }
    
    // Send email (example with Resend)
    // await resend.emails.send({ ... });
    
    console.log('ðŸ“§ [Contact] Email sent successfully');
    
    return new Response(
      JSON.stringify({ 
        success: true,
        message: 'Email sent successfully'
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
    
  } catch (error) {
    console.error('ðŸ“§ [Contact] Error:', error);
    
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
};
```

**Frontend Usage**:

```astro
---
// contact.astro
---

<form id="contact-form">
  <input type="email" name="email" required />
  <input type="text" name="subject" required />
  <textarea name="message" required></textarea>
  <button type="submit">Send</button>
</form>

<script>
  const form = document.getElementById('contact-form');
  
  form?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.target as HTMLFormElement);
    const data = Object.fromEntries(formData);
    
    try {
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      const result = await response.json();
      
      if (response.ok) {
        alert('Message sent!');
      } else {
        alert(`Error: ${result.error}`);
      }
    } catch (error) {
      console.error('Fetch error:', error);
      alert('Failed to send message');
    }
  });
</script>
```

## Testing & Validation

### Local Testing
```bash
npm run dev
```

1. Open DevTools â†’ Network tab
2. Submit your form
3. Verify the request to `/api/contact` returns JSON with status 200

### Production Validation

After deploying to Vercel:

1. Go to Vercel Dashboard â†’ Your Project â†’ Functions tab
2. Submit your form
3. Check the function logs - you should see your `console.log` statements
4. Verify logs show function execution, NOT "HIT" (which indicates static serving)

## Troubleshooting Checklist

If issues persist, verify:

- [ ] `output: 'server'` in `astro.config.mjs`
- [ ] Using `@astrojs/vercel` (not `/serverless`)
- [ ] `export const prerender = false;` in each API route
- [ ] No `vercel.json` file (or minimal if needed)
- [ ] No duplicate API definitions
- [ ] All responses return JSON with proper `Content-Type` header
- [ ] Environment variables are set in Vercel Dashboard
- [ ] No custom build scripts modifying `dist/server/`

## Common Patterns

### Pattern: Migration from External Forms

If you're migrating from Tally, Typeform, or similar:

1. Create Astro page with native form
2. Create API route in `src/pages/api/`
3. Add `prerender = false`
4. Implement handler with email service (Resend, Postmark, etc.)
5. Test locally, then deploy
6. Verify in Vercel Functions tab

### Pattern: Multiple API Endpoints

For projects with multiple APIs (newsletter, contact, download):

```
src/pages/api/
â”œâ”€â”€ contact.ts       â†’ export const prerender = false;
â”œâ”€â”€ newsletter.ts    â†’ export const prerender = false;
â””â”€â”€ download-pdf.ts  â†’ export const prerender = false;
```

Each follows the same structure - no special configuration needed.

## Environment Variables

Don't forget to set in Vercel Dashboard:

```bash
RESEND_API_KEY=re_xxxxx
PUBLIC_SITE_URL=https://yourdomain.com
WEBHOOK_URL=https://...
# Add others as needed
```

## Key Takeaways

1. **Single source of truth**: Use Astro routes OR Vercel functions, never both for the same endpoint
2. **Let the adapter work**: Don't override with `vercel.json` unless necessary
3. **Always disable prerendering**: `export const prerender = false;` for dynamic routes
4. **Always return JSON**: Even for errors
5. **Log strategically**: Use prefixed logs (`ðŸ“§ [Route]`) to track execution
6. **Don't touch dist/**: Never manually modify build output

## Resources

- [Astro on Vercel Documentation](https://vercel.com/docs/frameworks/astro)
- [Astro Server-side Rendering](https://docs.astro.build/en/guides/server-side-rendering/)
- [Astro API Routes](https://docs.astro.build/en/core-concepts/endpoints/)
- [Vercel Serverless Functions](https://vercel.com/docs/functions/serverless-functions)

## Contributing

Found this helpful? Have additional insights? Feel free to open an issue or PR to improve this guide.

---

**License**: MIT  
**Author**: Florent / LesWWW  
**Last Updated**: November 2025

This guide is based on real production experience solving API deployment issues on Astro + Vercel. Hope it saves you hours of debugging! ðŸš€
